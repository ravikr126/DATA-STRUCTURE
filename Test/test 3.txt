test 3
check cousins
// Following is the Binary Tree node structure
/**************
class BinaryTreeNode {
    public : 
    T data;
    BinaryTreeNode<T> *left;
    BinaryTreeNode<T> *right;

    BinaryTreeNode(T data) {
        this -> data = data;
        left = NULL;
        right = NULL;
    }
};
***************/
int depth(BinaryTreeNode<int> *root, int node)
{
    if(root==NULL)
        return -1;
    if(node == root->data)
        return 0;
    int left = depth(root->left,node);
    if(left != -1)
        return left+1;
    else{
        int right = depth(root->right,node);
        if(right != -1)
            return right+1;
        else
            return -1;
    }
}

bool isSibling(BinaryTreeNode<int> *root, int p, int q){
    if(root==NULL)
        return false;
    if(root -> left!=NULL && root ->right !=NULL){
        if(root->left->data == p&& root->right->data ==q)
            return true;
        else if(root->left->data == q && root->right->data == p)
            return true;
        else
            return isSibling(root->left, p,q) || isSibling(root->right,p,q);
    }
    if(root->right!=NULL)
        return isSibling(root->right,p,q);
    else
        return isSibling(root->left,p,q);
}

bool isCousin(BinaryTreeNode<int> *root, int p, int q){
    if(root==NULL)
        return false;
    return ((depth(root,p)==depth(root,q))&&(!isSibling(root,p,q)));
}



longest leaf

// Following is the Binary Tree node structure
/**************
class BinaryTreeNode {
    public : 
    T data;
    BinaryTreeNode<T> *left;
    BinaryTreeNode<T> *right;

    BinaryTreeNode(T data) {
        this -> data = data;
        left = NULL;
        right = NULL;
    }
};
***************/

vector<int>* longestPath(BinaryTreeNode<int>* root) {
	// Write your code here
    if(root==NULL)
        return NULL;
    if(!root->left&&!root->right)
    {
        vector<int>* output = new vector<int>();
        output->push_back(root->data);
        return output;
    }
    vector<int>* leftAns=longestPath(root->left);
    vector<int>* rightAns=longestPath(root->right);
    if(!leftAns){
        rightAns->push_back(root->data);
            return rightAns;
    }
    else if(!rightAns){
        leftAns->push_back(root->data);
        return leftAns;
    }
    else
    {
        if(leftAns->size()<rightAns->size())
        {
            rightAns->push_back(root->data);
            delete leftAns;
            return rightAns;
        }
        else
        {
            leftAns->push_back(root->data);
            delete rightAns;
            return leftAns;
        }
    }
}

remove leaf


// Following is the given Tree node structure.
/**************
class TreeNode {
	TreeNode<T>** children;
	int childCount;

	public:
	T data;

	TreeNode(T data);	// Constructor
	int numChildren();
	void addChild(TreeNode<T>* child);
	TreeNode<T>* getChild(int index);
	void setChild(int index, TreeNode<T>* child);
    void removeChild(int index);
 
};
***************/
# include <vector>
TreeNode<int>* removeLeafNodes(TreeNode<int>* root) {
    // Write your code here
    if(root==NULL || root->numChildren()==0)
    {
        return NULL;
    }
    vector<int> indexes;
    for(int i=0;i<root->numChildren();i++)
    {
        TreeNode<int> *child = root -> getChild(i);
        if(child->numChildren()==0)
        {
            indexes.push_back(i);
        }
    }
    for(int i=indexes.size()-1;i>=0;i--)
    {
        int j=indexes[i];
        root->removeChild(j);
    }
    for(int i=0;i<root->numChildren();i++)
    {
        TreeNode<int>*child=removeLeafNodes(root->getChild(i));
        if(child==NULL)
        {
            root->removeChild(i);
        }
    }
    return root;

}

